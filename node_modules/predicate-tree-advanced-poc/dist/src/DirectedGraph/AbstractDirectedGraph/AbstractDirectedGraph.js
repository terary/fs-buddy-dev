"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _AbstractDirectedGraph_fromPojoTraverseAndExtractChildren, _AbstractDirectedGraph_fromPojo;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericDirectedGraph = exports.AbstractDirectedGraph = void 0;
const treeUtilities_1 = __importDefault(require("./treeUtilities"));
const DirectedGraphError_1 = require("../DirectedGraphError");
const AbstractTree_1 = require("../AbstractTree/AbstractTree");
const defaultFromPojoTransform = (nodeContent) => {
    return nodeContent.nodeContent;
};
class AbstractDirectedGraph extends AbstractTree_1.AbstractTree {
    appendChildNodeWithContent(parentNodeId, nodeContent) {
        return super.appendChildNodeWithContent(parentNodeId, nodeContent);
    }
    cloneAt(nodeId) {
        const pojo = this.toPojoAt(nodeId);
        return AbstractDirectedGraph.fromPojo(pojo, defaultFromPojoTransform);
    }
    /**
     * The tricky bit here is that the  subtree._rootNodeId
     * must be the same as parent's node.nodeId
     * @param targetParentNodeId
     * @returns
     */
    createSubtreeAt(parentNodeId) {
        // can we rethink this.  Is there a better way?
        // @ts-ignore - not newable, I believe ok in javascript, not ok in typescript
        const subtree = new this.constructor(parentNodeId);
        const subtreeParentNodeId = super.appendChildNodeWithContent(parentNodeId, subtree);
        subtree._rootNodeId = subtreeParentNodeId;
        subtree._nodeDictionary = {};
        subtree._nodeDictionary[subtree._rootNodeId] = { nodeContent: null };
        subtree._incrementor = this._incrementor;
        return subtree;
    }
    fromPojoAppendChildNodeWithContent(parentNodeId, nodeContent) {
        return this.appendChildNodeWithContent(parentNodeId, nodeContent);
    }
    static getNewInstance(rootSeedNodeId, nodeContent) {
        // class GenericDirectedGraph extends AbstractDirectedGraph<P> {}
        return new GenericDirectedGraph(rootSeedNodeId, nodeContent);
    }
    static fromPojo(srcPojoTree, transform = defaultFromPojoTransform
    //    TreeClassBuilder?: (rootNodeId?: string, nodeContent?: P) => IDirectedGraph<P>
    ) {
        return __classPrivateFieldGet(AbstractDirectedGraph, _a, "m", _AbstractDirectedGraph_fromPojo).call(AbstractDirectedGraph, srcPojoTree, transform);
    }
}
exports.AbstractDirectedGraph = AbstractDirectedGraph;
_a = AbstractDirectedGraph, _AbstractDirectedGraph_fromPojo = function _AbstractDirectedGraph_fromPojo(srcPojoTree, transform = defaultFromPojoTransform // branch coverage complains
) {
    const pojoObject = Object.assign({}, srcPojoTree);
    const rootNodeId = treeUtilities_1.default.parseUniquePojoRootKeyOrThrow(pojoObject);
    const rootNodePojo = pojoObject[rootNodeId];
    // const dTree = TreeClassBuilder("root"); // as AbstractTree<T>;
    const dTree = AbstractDirectedGraph.getNewInstance();
    dTree.replaceNodeContent(dTree.rootNodeId, transform(rootNodePojo));
    delete pojoObject[rootNodeId];
    __classPrivateFieldGet(AbstractDirectedGraph, _a, "f", _AbstractDirectedGraph_fromPojoTraverseAndExtractChildren).call(AbstractDirectedGraph, dTree._rootNodeId, rootNodeId, dTree, pojoObject, transform);
    if (Object.keys(pojoObject).length > 0) {
        throw new DirectedGraphError_1.DirectedGraphError("Orphan nodes detected while parsing pojo object.");
    }
    return dTree;
};
_AbstractDirectedGraph_fromPojoTraverseAndExtractChildren = { value: (treeParentId, jsonParentId, dTree, treeObject, transformer, fromToMap = []) => {
        // ): void => {
        const childrenNodes = treeUtilities_1.default.extractChildrenNodes(jsonParentId, treeObject);
        Object.entries(childrenNodes).forEach(([nodeId, nodePojo]) => {
            if (nodePojo.nodeType === AbstractTree_1.AbstractTree.SubtreeNodeTypeName) {
                const subtree = dTree.createSubtreeAt(treeParentId);
                subtree.replaceNodeContent(subtree.rootNodeId, transformer(nodePojo));
                __classPrivateFieldGet(AbstractDirectedGraph, _a, "f", _AbstractDirectedGraph_fromPojoTraverseAndExtractChildren).call(AbstractDirectedGraph, subtree.rootNodeId, nodeId, subtree, treeObject, transformer, fromToMap);
            }
            else {
                const childId = dTree.fromPojoAppendChildNodeWithContent(treeParentId, transformer(nodePojo));
                fromToMap.push({ from: nodeId, to: childId });
                __classPrivateFieldGet(AbstractDirectedGraph, _a, "f", _AbstractDirectedGraph_fromPojoTraverseAndExtractChildren).call(AbstractDirectedGraph, childId, nodeId, dTree, treeObject, transformer, fromToMap);
            }
        });
        return fromToMap;
    } };
class GenericDirectedGraph extends AbstractDirectedGraph {
}
exports.GenericDirectedGraph = GenericDirectedGraph;
//# sourceMappingURL=AbstractDirectedGraph.js.map